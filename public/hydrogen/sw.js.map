{"version":3,"file":"sw.js","sources":["../sw.js"],"sourcesContent":["/*\r\nCopyright 2025 New Vector Ltd.\r\nCopyright 2020 Bruno Windels <bruno@windels.cloud>\r\nCopyright 2020 The Matrix.org Foundation C.I.C.\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nconst NOTIFICATION_BADGE_ICON = \"icon.png\";\r\n\r\n// These are replaced by rollup plugins\r\nconst UNHASHED_PRECACHED_ASSETS = DEFINE_UNHASHED_PRECACHED_ASSETS;\r\nconst HASHED_PRECACHED_ASSETS = DEFINE_HASHED_PRECACHED_ASSETS;\r\nconst HASHED_CACHED_ON_REQUEST_ASSETS = DEFINE_HASHED_CACHED_ON_REQUEST_ASSETS;\r\n\r\nconst unhashedCacheName = `hydrogen-assets-${DEFINE_GLOBAL_HASH}`;\r\nconst hashedCacheName = `hydrogen-assets`;\r\nconst mediaThumbnailCacheName = `hydrogen-media-thumbnails-v2`;\r\n\r\nself.addEventListener(\"install\", function (e) {\r\n    e.waitUntil(\r\n        (async () => {\r\n            const unhashedCache = await caches.open(unhashedCacheName);\r\n            await unhashedCache.addAll(UNHASHED_PRECACHED_ASSETS);\r\n            const hashedCache = await caches.open(hashedCacheName);\r\n            await Promise.all(\r\n                HASHED_PRECACHED_ASSETS.map(async (asset) => {\r\n                    if (!(await hashedCache.match(asset))) {\r\n                        await hashedCache.add(asset);\r\n                    }\r\n                })\r\n            );\r\n        })()\r\n    );\r\n});\r\n\r\nself.addEventListener(\"activate\", (event) => {\r\n    // on a first page load/sw install,\r\n    // start using the service worker on all pages straight away\r\n    self.clients.claim();\r\n    event.waitUntil(purgeOldCaches());\r\n});\r\n\r\nasync function purgeOldCaches() {\r\n    // remove any caches we don't know about\r\n    const keyList = await caches.keys();\r\n    for (const key of keyList) {\r\n        if (\r\n            key !== unhashedCacheName &&\r\n            key !== hashedCacheName &&\r\n            key !== mediaThumbnailCacheName\r\n        ) {\r\n            await caches.delete(key);\r\n        }\r\n    }\r\n    // remove the cache for any old hashed resource\r\n    const hashedCache = await caches.open(hashedCacheName);\r\n    const keys = await hashedCache.keys();\r\n    const hashedAssetURLs = HASHED_PRECACHED_ASSETS.concat(\r\n        HASHED_CACHED_ON_REQUEST_ASSETS\r\n    ).map((a) => new URL(a, self.registration.scope).href);\r\n\r\n    for (const request of keys) {\r\n        if (!hashedAssetURLs.some((url) => url === request.url)) {\r\n            hashedCache.delete(request);\r\n        }\r\n    }\r\n}\r\n\r\nself.addEventListener(\"fetch\", (event) => {\r\n    /*\r\n    service worker shouldn't handle xhr uploads because otherwise\r\n    the progress events won't fire.\r\n    This has to do with xhr not being supported in service workers.\r\n    */\r\n    if (event.request.method === \"GET\") {\r\n        event.respondWith(handleRequest(event));\r\n    }\r\n});\r\n\r\nfunction isCacheableThumbnail(url) {\r\n    if (\r\n        url.pathname.startsWith(\"/_matrix/media/r0/thumbnail/\") ||\r\n        url.pathname.startsWith(\"/_matrix/client/v1/media/thumbnail/\")\r\n    ) {\r\n        const width = parseInt(url.searchParams.get(\"width\"), 10);\r\n        const height = parseInt(url.searchParams.get(\"height\"), 10);\r\n        if (width <= 50 && height <= 50) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nconst baseURL = new URL(self.registration.scope);\r\nlet pendingFetchAbortController = new AbortController();\r\n\r\nasync function handleRequest({ request, clientId }) {\r\n    try {\r\n        // Special caching strategy for config.json and theme json files\r\n        if (\r\n            request.url.includes(\"config.json\") ||\r\n            /theme-.+\\.json/.test(request.url)\r\n        ) {\r\n            return handleStaleWhileRevalidateRequest(request);\r\n        }\r\n\r\n        // rewrite / to /index.html so it hits the cache\r\n        const url = new URL(request.url);\r\n        if (\r\n            url.origin === baseURL.origin &&\r\n            url.pathname === baseURL.pathname\r\n        ) {\r\n            request = new Request(new URL(\"index.html\", baseURL.href));\r\n        }\r\n\r\n        // Add access token for authenticated media endpoints\r\n        const pathNameStartsWithMediaPrefix =\r\n            url.pathname.indexOf(\"/_matrix/client/v1/media\") === 0;\r\n        if (pathNameStartsWithMediaPrefix) {\r\n            const client = await self.clients.get(clientId);\r\n            const { accessToken, homeserver } = await sendAndWaitForReply(\r\n                client,\r\n                \"getAuthInfo\",\r\n                {}\r\n            );\r\n            if (!accessToken) {\r\n                throw new Error(\r\n                    \"Token returned from getAuthInfo message in sw.js is null!\"\r\n                );\r\n            }\r\n            if (!homeserver) {\r\n                throw new Error(\r\n                    \"homeserver returned from getAuthInfo message in sw.js is null!\"\r\n                );\r\n            }\r\n            // Is this request actually going to the homeserver?\r\n            const isRequestForHomeserver =\r\n                new URL(homeserver).origin === url.origin;\r\n            if (isRequestForHomeserver) {\r\n                // Only add the access-token if we know that this request\r\n                // is going to the homeserver.\r\n                const headers = new Headers(request.headers);\r\n                headers.set(\"authorization\", `Bearer ${accessToken}`);\r\n                request = new Request(request, {\r\n                    mode: \"cors\",\r\n                    credentials: \"omit\",\r\n                    headers,\r\n                });\r\n            }\r\n        }\r\n\r\n        let response = await readCache(request);\r\n        if (!response) {\r\n            // use cors so the resource in the cache isn't opaque and uses up to 7mb\r\n            // https://developers.google.com/web/tools/chrome-devtools/progressive-web-apps?utm_source=devtools#opaque-responses\r\n            if (isCacheableThumbnail(url)) {\r\n                response = await fetch(request, {\r\n                    signal: pendingFetchAbortController.signal,\r\n                    mode: \"cors\",\r\n                    credentials: \"omit\",\r\n                });\r\n            } else {\r\n                response = await fetch(request, {\r\n                    signal: pendingFetchAbortController.signal,\r\n                });\r\n            }\r\n            await updateCache(request, response);\r\n        }\r\n        return response;\r\n    } catch (err) {\r\n        if (err.name !== \"TypeError\" && err.name !== \"AbortError\") {\r\n            console.error(\"error in service worker\", err);\r\n        }\r\n        throw err;\r\n    }\r\n}\r\n\r\n/**\r\n * Stale-while-revalidate caching for certain files\r\n * see https://developer.chrome.com/docs/workbox/caching-strategies-overview/#stale-while-revalidate\r\n */\r\nasync function handleStaleWhileRevalidateRequest(request) {\r\n    let response = await readCache(request);\r\n    const networkResponsePromise = fetchAndUpdateCache(request);\r\n    if (response) {\r\n        return response;\r\n    } else {\r\n        return await networkResponsePromise;\r\n    }\r\n}\r\n\r\nasync function fetchAndUpdateCache(request) {\r\n    const response = await fetch(request, {\r\n        signal: pendingFetchAbortController.signal,\r\n        headers: {\r\n            \"Cache-Control\": \"no-cache\",\r\n        },\r\n    });\r\n    updateCache(request, response.clone());\r\n    return response;\r\n}\r\n\r\nasync function updateCache(request, response) {\r\n    // don't write error responses to the cache\r\n    if (response.status >= 400) {\r\n        return;\r\n    }\r\n    const url = new URL(request.url);\r\n    const baseURL = self.registration.scope;\r\n    if (isCacheableThumbnail(url)) {\r\n        const cache = await caches.open(mediaThumbnailCacheName);\r\n        cache.put(request, response.clone());\r\n    } else if (request.url.startsWith(baseURL)) {\r\n        let assetName = request.url.substr(baseURL.length);\r\n        let cacheName;\r\n        if (HASHED_CACHED_ON_REQUEST_ASSETS.includes(assetName)) {\r\n            cacheName = hashedCacheName;\r\n        } else if (UNHASHED_PRECACHED_ASSETS.includes(assetName)) {\r\n            cacheName = unhashedCacheName;\r\n        }\r\n        if (cacheName) {\r\n            const cache = await caches.open(cacheName);\r\n            await cache.put(request, response.clone());\r\n        }\r\n    }\r\n}\r\n\r\nasync function readCache(request) {\r\n    const unhashedCache = await caches.open(unhashedCacheName);\r\n    let response = await unhashedCache.match(request);\r\n    if (response) {\r\n        return response;\r\n    }\r\n    const hashedCache = await caches.open(hashedCacheName);\r\n    response = await hashedCache.match(request);\r\n    if (response) {\r\n        return response;\r\n    }\r\n\r\n    const url = new URL(request.url);\r\n    if (isCacheableThumbnail(url)) {\r\n        const mediaThumbnailCache = await caches.open(mediaThumbnailCacheName);\r\n        response = await mediaThumbnailCache.match(request);\r\n        // added in 0.1.26, remove previously cached error responses, remove this in some time\r\n        if (response?.status >= 400) {\r\n            await mediaThumbnailCache.delete(request);\r\n            response = null;\r\n        }\r\n    }\r\n    return response;\r\n}\r\n\r\nself.addEventListener(\"message\", (event) => {\r\n    const reply = (payload) =>\r\n        event.source.postMessage({ replyTo: event.data.id, payload });\r\n    const { replyTo } = event.data;\r\n    if (replyTo) {\r\n        const resolve = pendingReplies.get(replyTo);\r\n        if (resolve) {\r\n            pendingReplies.delete(replyTo);\r\n            resolve(event.data.payload);\r\n        }\r\n    } else {\r\n        switch (event.data?.type) {\r\n            case \"version\":\r\n                reply({\r\n                    version: DEFINE_VERSION,\r\n                    buildHash: DEFINE_GLOBAL_HASH,\r\n                });\r\n                break;\r\n            case \"skipWaiting\":\r\n                self.skipWaiting();\r\n                break;\r\n            case \"haltRequests\":\r\n                event.waitUntil(haltRequests().finally(() => reply()));\r\n                break;\r\n            case \"closeSession\":\r\n                event.waitUntil(\r\n                    closeSession(\r\n                        event.data.payload.sessionId,\r\n                        event.source.id\r\n                    ).finally(() => reply())\r\n                );\r\n                break;\r\n        }\r\n    }\r\n});\r\n\r\nconst NOTIF_TAG_NEW_MESSAGE = \"new_message\";\r\n\r\nasync function openClientFromNotif(event) {\r\n    if (event.notification.tag !== NOTIF_TAG_NEW_MESSAGE) {\r\n        console.log(\"clicked notif with tag\", event.notification.tag);\r\n        return;\r\n    }\r\n    const { sessionId, roomId } = event.notification.data;\r\n    const sessionHash = `#/session/${sessionId}`;\r\n    const roomHash = `${sessionHash}/room/${roomId}`;\r\n    const clientWithSession = await findClient(async (client) => {\r\n        return await sendAndWaitForReply(client, \"hasSessionOpen\", {\r\n            sessionId,\r\n        });\r\n    });\r\n    if (clientWithSession) {\r\n        console.log(\r\n            \"notificationclick: client has session open, showing room there\"\r\n        );\r\n        // use a message rather than clientWithSession.navigate here as this refreshes the page on chrome\r\n        clientWithSession.postMessage({\r\n            type: \"openRoom\",\r\n            payload: { roomId },\r\n        });\r\n        if (\"focus\" in clientWithSession) {\r\n            try {\r\n                await clientWithSession.focus();\r\n            } catch (err) {\r\n                console.error(err);\r\n            } // I've had this throw on me on Android\r\n        }\r\n    } else if (self.clients.openWindow) {\r\n        console.log(\r\n            \"notificationclick: no client found with session open, opening new window\"\r\n        );\r\n        const roomURL = new URL(`./${roomHash}`, baseURL).href;\r\n        await self.clients.openWindow(roomURL);\r\n    }\r\n}\r\n\r\nself.addEventListener(\"notificationclick\", (event) => {\r\n    event.notification.close();\r\n    event.waitUntil(openClientFromNotif(event));\r\n});\r\n\r\nasync function handlePushNotification(n) {\r\n    console.log(\"got a push message\", n);\r\n    const sessionId = n.session_id;\r\n    let sender = n.sender_display_name || n.sender;\r\n    if (sender && n.event_id) {\r\n        const roomId = n.room_id;\r\n        const hasFocusedClientOnRoom = !!(await findClient(async (client) => {\r\n            if (client.visibilityState === \"visible\" && client.focused) {\r\n                return await sendAndWaitForReply(client, \"hasRoomOpen\", {\r\n                    sessionId,\r\n                    roomId,\r\n                });\r\n            }\r\n        }));\r\n        if (hasFocusedClientOnRoom) {\r\n            console.log(\"client is focused, room is open, don't show notif\");\r\n            return;\r\n        }\r\n        const newMessageNotifs = Array.from(\r\n            await self.registration.getNotifications({\r\n                tag: NOTIF_TAG_NEW_MESSAGE,\r\n            })\r\n        );\r\n        const notifsForRoom = newMessageNotifs.filter(\r\n            (n) => n.data.roomId === roomId\r\n        );\r\n        const hasMultiNotification = notifsForRoom.some((n) => n.data.multi);\r\n        const hasSingleNotifsForRoom = newMessageNotifs.some(\r\n            (n) => !n.data.multi\r\n        );\r\n        const roomName = n.room_name || n.room_alias;\r\n        let multi = false;\r\n        let label;\r\n        let body;\r\n        if (hasMultiNotification) {\r\n            console.log(\"already have a multi message, don't do anything\");\r\n            return;\r\n        } else if (hasSingleNotifsForRoom) {\r\n            console.log(\"showing multi message notification\");\r\n            multi = true;\r\n            label = roomName || sender;\r\n            body = \"New messages\";\r\n        } else {\r\n            console.log(\"showing new message notification\");\r\n            if (roomName && roomName !== sender) {\r\n                label = `${sender} in ${roomName}`;\r\n            } else {\r\n                label = sender;\r\n            }\r\n            body = n.content?.body || \"New message\";\r\n        }\r\n        await self.registration.showNotification(label, {\r\n            body,\r\n            data: { sessionId, roomId, multi },\r\n            tag: NOTIF_TAG_NEW_MESSAGE,\r\n            badge: NOTIFICATION_BADGE_ICON,\r\n        });\r\n    }\r\n    // we could consider hiding previous notifications here based on the unread count\r\n    // (although we can't really figure out which notifications to hide) and also hiding\r\n    // notifications makes it hard to ensure we always show a notification after a push message\r\n    // when no client is visible, see https://goo.gl/yqv4Q4\r\n}\r\n\r\nself.addEventListener(\"push\", (event) => {\r\n    event.waitUntil(handlePushNotification(event.data.json()));\r\n});\r\n\r\nasync function closeSession(sessionId, requestingClientId) {\r\n    const clients = await self.clients.matchAll();\r\n    await Promise.all(\r\n        clients.map(async (client) => {\r\n            if (client.id !== requestingClientId) {\r\n                await sendAndWaitForReply(client, \"closeSession\", {\r\n                    sessionId,\r\n                });\r\n            }\r\n        })\r\n    );\r\n}\r\n\r\nasync function haltRequests() {\r\n    // first ask all clients to block sending any more requests\r\n    const clients = await self.clients.matchAll({ type: \"window\" });\r\n    await Promise.all(\r\n        clients.map((client) => {\r\n            return sendAndWaitForReply(client, \"haltRequests\");\r\n        })\r\n    );\r\n    // and only then abort the current requests\r\n    pendingFetchAbortController.abort();\r\n}\r\n\r\nconst pendingReplies = new Map();\r\nlet messageIdCounter = 0;\r\nfunction sendAndWaitForReply(client, type, payload) {\r\n    messageIdCounter += 1;\r\n    const id = messageIdCounter;\r\n    const promise = new Promise((resolve) => {\r\n        pendingReplies.set(id, resolve);\r\n    });\r\n    client.postMessage({ type, id, payload });\r\n    return promise;\r\n}\r\n\r\nasync function findClient(predicate) {\r\n    const clientList = await self.clients.matchAll({ type: \"window\" });\r\n    for (const client of clientList) {\r\n        if (await predicate(client)) {\r\n            return client;\r\n        }\r\n    }\r\n}\r\n"],"names":["NOTIFICATION_BADGE_ICON","UNHASHED_PRECACHED_ASSETS","HASHED_PRECACHED_ASSETS","HASHED_CACHED_ON_REQUEST_ASSETS","unhashedCacheName","hashedCacheName","mediaThumbnailCacheName","hashedCache","asset","event","purgeOldCaches","keyList","key","keys","hashedAssetURLs","a","request","url","handleRequest","isCacheableThumbnail","width","height","baseURL","pendingFetchAbortController","clientId","handleStaleWhileRevalidateRequest","client","accessToken","homeserver","sendAndWaitForReply","headers","response","readCache","updateCache","err","networkResponsePromise","fetchAndUpdateCache","assetName","cacheName","mediaThumbnailCache","_a","reply","payload","replyTo","resolve","pendingReplies","haltRequests","closeSession","NOTIF_TAG_NEW_MESSAGE","openClientFromNotif","sessionId","roomId","roomHash","clientWithSession","findClient","roomURL","handlePushNotification","n","sender","newMessageNotifs","hasMultiNotification","hasSingleNotifsForRoom","roomName","multi","label","body","requestingClientId","clients","messageIdCounter","type","id","promise","predicate","clientList"],"mappings":"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"}